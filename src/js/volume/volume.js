
/*jslint browser: true, node: true */
/*global GUNZIP_MAGIC_COOKIE1, GUNZIP_MAGIC_COOKIE2, Base64Binary, pako, numeric */

"use strict";

/*** Imports ***/
var papaya = papaya || {};
papaya.volume = papaya.volume || {};


/*** Constructor ***/
papaya.volume.Volume = papaya.volume.Volume || function (progressMeter, dialogHandler, params) {
    this.progressMeter = progressMeter;
    this.dialogHandler = dialogHandler;
    this.files = [];
    this.rawData = [];
    this.fileLength = 0;
    this.urls = null;
    this.fileName = null;
    this.compressed = false;
    this.transform = null;
    this.numTimepoints = 0;
    this.onFinishedRead = null;
    this.error = null;
    this.transform = null;
    this.isLoaded = false;
    this.numTimepoints = 1;
    this.loaded = false;
    this.params = params;

    this.header = new papaya.volume.Header((this.params !== undefined) && this.params.padAllImages);
    this.imageData = new papaya.volume.ImageData((this.params !== undefined) && this.params.padAllImages);

    // Modification 28/11/2019: add reactPapayaViewport
    this.reactPapayaViewport = null;
};


/*** Static Pseudo-constants ***/

papaya.volume.Volume.PROGRESS_LABEL_LOADING = "Loading";


/*** Prototype Methods ***/

papaya.volume.Volume.prototype.fileIsCompressed = function (filename, data) {
    var buf, magicCookie1, magicCookie2;

    if (filename && filename.indexOf(".gz") !== -1) {
        return true;
    }

    if (data) {
        buf = new DataView(data);

        magicCookie1 = buf.getUint8(0);
        magicCookie2 = buf.getUint8(1);

        if (magicCookie1 === GUNZIP_MAGIC_COOKIE1) {
            return true;
        }

        if (magicCookie2 === GUNZIP_MAGIC_COOKIE2) {
            return true;
        }
    }

    return false;
};



papaya.volume.Volume.prototype.readFiles = function (files, callback) {
    this.files = files;
    this.fileName = files[0].name;
    this.onFinishedRead = callback;
    this.compressed = this.fileIsCompressed(this.fileName);
    this.fileLength = this.files[0].size;
    this.readNextFile(this, 0);
};



papaya.volume.Volume.prototype.readNextFile = function (vol, index) {
    var blob;

    if (index < this.files.length) {
        blob = papaya.utilities.PlatformUtils.makeSlice(this.files[index], 0, this.files[index].size);

        try {
            var reader = new FileReader();

            reader.onloadend = papaya.utilities.ObjectUtils.bind(vol, function (evt) {
                if (evt.target.readyState === FileReader.DONE) {
                    vol.rawData[index] = evt.target.result;
                    setTimeout(function () {vol.readNextFile(vol, index + 1); }, 0);
                }
            });

            reader.onerror = papaya.utilities.ObjectUtils.bind(vol, function (evt) {
                vol.error = new Error("There was a problem reading that file:\n\n" + evt.getMessage());
                vol.finishedLoad();
            });

            reader.readAsArrayBuffer(blob);
        } catch (err) {
            vol.error = new Error("There was a problem reading that file:\n\n" + err.message);
            vol.finishedLoad();
        }
    } else {
        setTimeout(function () {vol.decompress(vol); }, 0);
    }
};



papaya.volume.Volume.prototype.readURLs = function (urls, callback) {
    var self = this;
    this.urls = urls;
    this.fileName = urls[0].substr(urls[0].lastIndexOf("/") + 1, urls[0].length);
    this.onFinishedRead = callback;
    this.compressed = this.fileIsCompressed(this.fileName);

    if (this.fileName.indexOf("?") !== -1) {
        this.fileName = this.fileName.substr(0, this.fileName.indexOf("?"));
    }

    this.rawData = [];
    this.loadedFileCount = 0;
    this.readEachURL(this)
        .done(function () {
            // recieves `arguments` which are results off xhr requests
            setTimeout(function () {self.decompress(self); }, 0);
        })
        .fail(function (vol, err, xhr) {

            var message = err.message || '';
            // if error came from ajax request
            if ( typeof xhr !== "undefined" ) {
                message = "Response status = " + xhr.status;
            }

            vol.error = new Error("There was a problem reading that file (" +
                vol.fileName + "):\n\n" + message);
            vol.finishedLoad();
        });
};



papaya.volume.Volume.prototype.loadURL = function (url, vol, index) {
    var supported, deferredLoading, xhr, progPerc, progressText;

    deferredLoading = jQuery.Deferred();

    supported = typeof new XMLHttpRequest().responseType === 'string';
    if (supported) {
        xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'arraybuffer';

        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                    vol.fileLength = vol.rawData.byteLength;
                    deferredLoading.resolve( xhr.response );
                } else {
                    deferredLoading.reject(vol,false,xhr);
                }
            }
        };

        xhr.onprogress = function (evt) {
            if(evt.lengthComputable) {
                deferredLoading.notify(evt.loaded, evt.total);
            }
        };

        xhr.send(null);
    } else {
        vol.error = new Error("There was a problem reading that file (" + vol.fileName +
            "):\n\nResponse type is not supported.");
        vol.finishedLoad();
    }

    var promise = deferredLoading
        .promise()
        .done(function (file) {
            vol.loadedFileCount++;
            vol.rawData[index] = file;
        })
        .fail(function (vol, err, xhr) {
            console.error(vol, err, xhr);
        })
        .progress(function (loaded,total) {
            progPerc = parseInt(100 * (vol.loadedFileCount) / vol.urls.length, 10);
            progressText = papaya.volume.Volume.PROGRESS_LABEL_LOADING +
                ' image ' + (vol.loadedFileCount + 1) + ' of ' + vol.urls.length + ' (' + progPerc + '%)';
            vol.progressMeter.drawProgress(loaded / total, progressText);
        });

    return promise;
};


papaya.volume.Volume.prototype.readEachURL = function (vol) {
    var deferredLoads = [];

    for (var i = 0; i < vol.urls.length; i++) {
        var getFileDeferred = vol.loadURL(vol.urls[i], vol, i);
        deferredLoads.push(getFileDeferred);
    }

    return $.when.apply($, deferredLoads);
};


papaya.volume.Volume.prototype.readBinaryData = function (dataRefs, callback) {
    var vol = null;

    try {

        if (dataRefs[0] instanceof ArrayBuffer) {
            this.fileName = "unknown";
        } else {
            this.fileName = dataRefs[0];
        }
        this.onFinishedRead = callback;
        vol = this;
        this.fileLength = 0;
        vol.readNextBinaryData(vol, 0, dataRefs);
    } catch (err) {
        if (vol) {
            vol.error = new Error("There was a problem reading that file:\n\n" + err.message);
            vol.finishedLoad();
        }
    }
};

papaya.volume.Volume.prototype.readNextBinaryData = function (vol, index, dataRefs) {
    if (index < dataRefs.length) {
        try {
            if (dataRefs[index] instanceof ArrayBuffer) {
                vol.rawData[index] = dataRefs[index];
            } else {
                vol.rawData[index] = papaya.utilities.ObjectUtils.dereference(dataRefs[index]);
            }

            vol.compressed = this.fileIsCompressed(this.fileName, vol.rawData[index]);
            setTimeout(function () {vol.readNextBinaryData(vol, index + 1, dataRefs); }, 0);
        } catch (err) {
            if (vol) {
                vol.error = new Error("There was a problem reading that file:\n\n" + err.message);
                vol.finishedLoad();
            }
        }
    } else {
        vol.decompress(vol);
    }
};

papaya.volume.Volume.prototype.readEncodedData = function (dataRefs, callback) {
    var vol = null;

    try {
        this.fileName = dataRefs[0];
        this.onFinishedRead = callback;
        vol = this;
        this.fileLength = 0;
        vol.readNextEncodedData(vol, 0, dataRefs);
    } catch (err) {
        if (vol) {
            vol.error = new Error("There was a problem reading that file:\n\n" + err.message);
            vol.finishedLoad();
        }
    }
};



papaya.volume.Volume.prototype.readNextEncodedData = function (vol, index, dataRefs) {
    if (index < dataRefs.length) {
        try {
            var deref = papaya.utilities.ObjectUtils.dereference(dataRefs[index]);

            if (deref) {
                vol.rawData[index] = Base64Binary.decodeArrayBuffer(deref);
            } else {
                this.fileName = "unknown";
                vol.rawData[index] = Base64Binary.decodeArrayBuffer(dataRefs[index]);
            }

            vol.compressed = this.fileIsCompressed(this.fileName, vol.rawData[index]);
            setTimeout(function () {vol.readNextEncodedData(vol, index + 1, dataRefs); }, 0);
        } catch (err) {
            if (vol) {
                vol.error = new Error("There was a problem reading that file:\n\n" + err.message);
                vol.finishedLoad();
            }
        }
    } else {
        vol.decompress(vol);
    }
};

/**
 * Custom read function for Cornerstone
 */
papaya.volume.Volume.prototype.readCornerstoneData = function (cornerstoneImages, stackMetadata, callback) {
    // var vol = null;
    if (cornerstoneImages) {
        this.fileName = 'cornerstone';
    }
    this.onFinishedRead = callback;
    var vol = this;
    // try {
    //     if (cornerstoneImages) {
    //         this.fileName = "unknown";
    //     }
    //     this.onFinishedRead = callback;
    //     vol = this;
    //     this.fileLength = 0;
    //     vol.readNextCornerstoneData(vol, 0, cornerstoneImages);
    // } catch (err) {
    //     if (vol) {
    //         vol.error = new Error("There was a problem reading that file:\n\n" + err.message);
    //         vol.finishedLoad();
    //     }
    // }

    vol.header.readHeaderData(vol.fileName, cornerstoneImages, this.progressMeter, this.dialogHandler, stackMetadata,
        papaya.utilities.ObjectUtils.bind(this, this.finishedReadHeaderData));
};

papaya.volume.Volume.prototype.readNextCornerstoneData = function (vol, index, cornerstoneImages) {
    if (index < cornerstoneImages.length) {
        try {
            console.log('readNextCornerstoneData', cornerstoneImages[index], index);
            setTimeout(function () {vol.readNextCornerstoneData(vol, index + 1, cornerstoneImages); }, 0);
        } catch (err) {
            if (vol) {
                vol.error = new Error("There was a problem reading that file:\n\n" + err.message);
                vol.finishedLoad();
            }
        }
    } else {
        // vol.decompress(vol);
        console.log('done');
    }
};

////////


papaya.volume.Volume.prototype.getVoxelAtIndexNative = function (ctrX, ctrY, ctrZ, timepoint, useNN) {
    return this.transform.getVoxelAtIndexNative(ctrX, ctrY, ctrZ, 0, useNN);
};



papaya.volume.Volume.prototype.getVoxelAtIndex = function (ctrX, ctrY, ctrZ, timepoint, useNN) {
    return this.transform.getVoxelAtIndex(ctrX, ctrY, ctrZ, timepoint, useNN);
};



papaya.volume.Volume.prototype.getVoxelAtCoordinate = function (xLoc, yLoc, zLoc, timepoint, useNN) {
    return this.transform.getVoxelAtCoordinate(xLoc, yLoc, zLoc, timepoint, useNN);
};



papaya.volume.Volume.prototype.getVoxelAtMM = function (xLoc, yLoc, zLoc, timepoint, useNN, sliceLabel) {
    return this.transform.getVoxelAtMM(xLoc, yLoc, zLoc, timepoint, useNN, sliceLabel);
};



papaya.volume.Volume.prototype.hasError = function () {
    return (this.error !== null);
};



papaya.volume.Volume.prototype.getXDim = function () {
    return this.header.imageDimensions.xDim;
};



papaya.volume.Volume.prototype.getYDim = function () {
    return this.header.imageDimensions.yDim;
};



papaya.volume.Volume.prototype.getZDim = function () {
    return this.header.imageDimensions.zDim;
};



papaya.volume.Volume.prototype.getXSize = function () {
    return this.header.voxelDimensions.xSize;
};



papaya.volume.Volume.prototype.getYSize = function () {
    return this.header.voxelDimensions.ySize;
};



papaya.volume.Volume.prototype.getZSize = function () {
    return this.header.voxelDimensions.zSize;
};



papaya.volume.Volume.prototype.decompress = function (vol) {
    vol.compressed = vol.compressed || vol.fileIsCompressed(vol.fileName, vol.rawData[0]);

    if (vol.compressed) {
        try {
            pako.inflate(new Uint8Array(vol.rawData[0]), null, this.progressMeter,
                function (data) {vol.finishedDecompress(vol, data.buffer); });
        } catch (err) {
            console.log(err);
        }
    } else {
        setTimeout(function () {vol.finishedReadData(vol); }, 0);
    }
};



papaya.volume.Volume.prototype.finishedDecompress = function (vol, data) {
    vol.rawData[0] = data;
    setTimeout(function () {vol.finishedReadData(vol); }, 0);
};



papaya.volume.Volume.prototype.finishedReadData = function (vol) {
    vol.rawData = papaya.utilities.ArrayUtils.cleanArray(vol.rawData);

    vol.header.readHeaderData(vol.fileName, vol.rawData, this.progressMeter, this.dialogHandler,
        papaya.utilities.ObjectUtils.bind(this, this.finishedReadHeaderData));
};



papaya.volume.Volume.prototype.finishedReadHeaderData = function () {
    this.rawData = null;

    if (this.header.hasError()) {
        // console.log('TROI OI LOI ROI', JSON.stringify(this.header.error));
        this.error = this.header.error;
        console.error(this.error.stack);
        this.onFinishedRead(this);
        return;
    }

    this.header.imageType.swapped = (this.header.imageType.littleEndian !== papaya.utilities.PlatformUtils.isPlatformLittleEndian());

    var name = this.header.getName();

    if (name) {
        this.fileName = this.header.getName();
    }

    this.header.readImageData(this.progressMeter, papaya.utilities.ObjectUtils.bind(this, this.finishedReadImageData));
};



papaya.volume.Volume.prototype.finishedReadImageData = function (imageData) {
    // console.log('papaya-imageData read', imageData); // DONT LOG IN PRODUCTION OR MEM LEAK
    this.imageData.readFileData(this.header, imageData, papaya.utilities.ObjectUtils.bind(this, this.finishedLoad));
};



papaya.volume.Volume.prototype.finishedLoad = function () {
    if (!this.loaded) {
        this.loaded = true;
        if (this.onFinishedRead) {
            if (!this.hasError()) {
                this.transform = new papaya.volume.Transform(papaya.volume.Transform.IDENTITY.clone(), this);
                this.numTimepoints = this.header.imageDimensions.timepoints || 1;
                this.applyBestTransform();
                // Moodification 28/11/2019: add setState callback to disable loading screen
                if (this.reactPapayaViewport) this.reactPapayaViewport.setState({ finishedLoading: true });
            } else {
                console.log(this.error);
            }

            this.isLoaded = true;
            this.rawData = null;
            this.onFinishedRead(this);
        }
    }
};



papaya.volume.Volume.prototype.setOrigin = function (coord) {
    var coordNew = this.header.orientation.convertCoordinate(coord, new papaya.core.Coordinate(0, 0, 0));
    this.header.origin.setCoordinate(coordNew.x, coordNew.y, coordNew.z);
};



papaya.volume.Volume.prototype.getOrigin = function () {
    return this.header.orientation.convertCoordinate(this.header.origin, new papaya.core.Coordinate(0, 0, 0));
};



papaya.volume.Volume.prototype.applyBestTransform = function () {
    var bestXform = this.header.getBestTransform();
    console.log('papaya-bestTransform', bestXform);
    if (bestXform !== null) {
        this.transform.worldMatNifti = numeric.inv(bestXform);
        this.setOrigin(this.header.getBestTransformOrigin());
        this.transform.updateWorldMat();
    }
};



papaya.volume.Volume.prototype.isWorldSpaceOnly = function () {
    /*jslint bitwise: true */

    var nifti, foundDataOrderTransform = false;

    if (this.header.fileFormat instanceof papaya.volume.nifti.HeaderNIFTI) {
        nifti = this.header.fileFormat;

        if (nifti.nifti.qform_code > 0) {
            foundDataOrderTransform |= !nifti.qFormHasRotations();
        }

        if (nifti.nifti.sform_code > 0) {
            foundDataOrderTransform |= !nifti.sFormHasRotations();
        }

        return !foundDataOrderTransform;
    }

    return false;
};



papaya.volume.Volume.prototype.getSeriesLabels = function () {
    return this.header.getSeriesLabels();
};

// modification 17/01/2020: add reset function

papaya.volume.Volume.prototype.reset = function (centerCoord) {
    var centerX, centerY, centerZ;
    centerX = centerCoord.x * this.header.voxelDimensions.xSize;
    centerY = centerCoord.y * this.header.voxelDimensions.ySize;
    centerZ = centerCoord.z * this.header.voxelDimensions.zSize;

    this.transform = new papaya.volume.Transform(papaya.volume.Transform.IDENTITY.clone(), this);
    this.transform.updateRollImageMat(0, 1);
    this.transform = new papaya.volume.Transform(papaya.volume.Transform.IDENTITY.clone(), this);
}

// modification 16/07/2020: add get voxel by worker

papaya.volume.Volume.prototype.workerGetVoxelAtMM = function (worker, workerProps) {
    this.transform.workerGetVoxelAtMM(worker, workerProps);
}

